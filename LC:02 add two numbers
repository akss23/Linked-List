class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // stack<int> s1, s2;
        // ListNode* temp1 = l1; 
        // ListNode* temp2 = l2;
        // while(temp1 != NULL){
        //     s1.push(temp1->val);
        //     temp1 = temp1->next;
        // }
        // while(temp2 != NULL){
        //     s2.push(temp2->val);
        //     temp2 = temp2->next;
        // }
        // long long n1 = 0, n2 = 0;
        // while(!s1.empty()){
        //     n1 = (n1 * 10) + s1.top();
        //     s1.pop();
        // }
        // while(!s2.empty()){
        //     n2 = (n2 * 10) + s2.top();
        //     s2.pop();
        // }
        // long long sum=n1+n2;
        // if(sum == 0) return new ListNode(0);
        // ListNode* dummy = new ListNode(0);
        // ListNode* curr = dummy;
        
        // while(sum > 0){
        //     int digit = sum % 10;
        //     curr->next = new ListNode(digit);
        //     curr = curr->next;
        //     sum /= 10;
        // }
        // return dummy->next; THIS IS THE BRUTE FORCE COZ HERE I USED STACKS TO FIRST REVRSE AND SHIT

        // now in the optimal approach, I'm goinf to add them in the very same format as they're given to me
       ListNode* t1=l1;
       ListNode* t2=l2;
       ListNode* dummy= new ListNode(-1);
       int carry=0;
       ListNode* curr=dummy;
       while(t1!=NULL || t2!=NULL){
            int s=carry;
            if(t1) s+=t1->val;
            if(t2) s+=t2->val;
            carry=s/10;
            ListNode* nn = new ListNode(s%10);
            curr->next=nn;//connected
            curr=curr->next;//incremented
            if(t1) t1=t1->next;
            if(t2) t2=t2->next;

       }
       if(carry) {
         ListNode* a=new ListNode(carry);
         curr->next=a;
       }
       return dummy->next;
    }
};
